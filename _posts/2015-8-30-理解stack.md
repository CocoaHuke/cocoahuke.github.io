---
layout: post
title: 理解stack
---
这个文章我当时写的描述可能有些难以理解.可以多看看我分享的pdf文档.
{% highlight bash %}
内存中的栈和堆:
栈由系统自动分配,栈是从高地址向低地址生长.
所以栈在高地址,堆接在执行文件映射到内存那块区域的最后面.给个例子:
比如TEXT段在100000000 - 100001000.在TEXT段后面还有DATA段等很多信息(基本后面都是只读或读写的段了)…
{% endhighlight %}
{% highlight bash %}
堆在这些东西的最后面,通常有着3个区域,微型区域为1MB,接受小于496字节的堆分配(这个496不是非常固定,内存会有变化).
小型区域为8MB,接受大于496小于15360字节的堆分配(同样不是非常固定,有时候会另外开一个内存区域).大型区域大小不固定.
当堆分配大于前两个区域时,就会另外开一个单独内存区域。
同样上一个例子,TEXT的栈的在大概0x00007fff5fbff7c0的位置,在这个例子中,栈的位置都是以7fff开头的了.栈会不停的变化.
{% endhighlight %}

{% highlight bash %}
栈的理解(重要的地方)
  调用一个函数,栈的变化,我尽可能用最好理解的方式解释:
    push就是向栈推入寄存器的值,pop是恢复到指定寄存器,push所推入的入口就是esp,所谓先进后出.call指令相当于一条push把下一条指令位置(ip指针)推入栈中(就是当作返回地址),然后jmp跳转,当然还有很多指令会使用到栈.
    调用一般会先把参数写入寄存器,或者推入栈中,然后call.
  先往当前栈(sp指针就像当前栈的入口)推入函数的参数,然后再推入函数的返回地址,然后就会跳转到那个函数的第一个指令..
    基本函数开头都是
   push       rbp                                     
   mov       rbp, rsp
   sub        rsp,0x40
类似这段代码,所以再推入当前rbp到栈里.当前栈底变栈顶(因为栈是从高地址不断扩充到低地址的),栈顶自减,相当于为刚刚跳转的函数扩充新的栈,所以栈的结构基本为:
低地址: Buffer(当前函数的栈)          <-SP指针指向开头.
              ———————————————————————————————————————————————————相当于栈的分割线,以上为当前栈,以下为上一个函数所使用的栈(不过现在保存返回地址,ebp,参数等)
              ebp指针(还记得函数开头的push  bp吗,这是上一个函数的ebp,就是上一个函数所使用的栈的esp位置,便于返回上一个函数时恢复)        <-BP指针指向这里开头(就是当前栈的栈底(bp)指针减去栈顶(SP)指针就是当前栈的范围)
              函数返回地址
              参数1
              参数2 (如果有多个参数被推入栈中的话,顺序是反的,从右往左依次推入栈中)
              ———————————————————————————————————————————————————
              ebp指针
              函数返回地址
              参数1
              参数2
             ————————————————————————————————————————————————————
            ...依次这样,直到返回main函数.
然后当前函数的结尾一般会有
add        rsp, 0x40
 pop        rbp
 ret 
类似这段代码
把当前栈顶(SP)加回去.
              ebp指针
              函数返回地址
              参数1
              参数2
           
然后恢复ebp指针,以这个例子,ebp会指向参数2后面的位置.
              函数返回地址
              参数1
              参数2
然后ret指令跳转函数的返回地址,
实际栈多变,需要以调试器为主.但是主要的规律还是一样的,希望读者可以理解.
{% endhighlight %}